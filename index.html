<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chimps INC Admin Terminal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Ensure no scrollbars on the main body */
        }
        /* The #root element will now be centered by the body's flex properties */
        .custom-scrollbar::-webkit-scrollbar {
          width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
          background: #0a0a0a;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
          background: var(--scrollbar-thumb-color, #10B981);
          border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
          background: var(--scrollbar-thumb-hover-color, #059669);
        }
        @keyframes blink {
          50% {
            opacity: 0;
          }
        }
        .blinking-cursor::after {
          content: '_';
          animation: blink 1s step-end infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        function App() {
          const [currentScreen, setCurrentScreen] = React.useState('terminal');
          const [isAccessRestricted, setIsAccessRestricted] = React.useState(false);
          const [showRestrictedMenu, setShowRestrictedMenu] = React.useState(false);
          const [isLoggedIn, setIsLoggedIn] = React.useState(false);

          const navigateTo = (screenName) => {
            setCurrentScreen(screenName);
          };

          React.useEffect(() => {
            if (isAccessRestricted) {
              console.log("App Component: isAccessRestricted is now TRUE. Rendering AccessRestrictedScreen.");
            }
          }, [isAccessRestricted]);

          return (
            // The main app container now centers its content, allowing background to show
            <div className="min-h-screen bg-gray-900 text-gray-100 font-inter flex items-center justify-center p-4">
              {isAccessRestricted ? (
                showRestrictedMenu ? (
                  <RestrictedAccessMenu
                    navigateTo={navigateTo}
                    setIsAccessRestricted={setIsAccessRestricted}
                    setShowRestrictedMenu={setShowRestrictedMenu}
                    isLoggedIn={isLoggedIn}
                  />
                ) : (
                  <AccessRestrictedScreen setShowRestrictedMenu={setShowRestrictedMenu} />
                )
              ) : (
                <>
                  {currentScreen === 'terminal' && <Terminal navigateTo={navigateTo} setIsAccessRestricted={setIsAccessRestricted} setShowRestrictedMenu={setShowRestrictedMenu} isLoggedIn={isLoggedIn} setIsLoggedIn={setIsLoggedIn} />}
                  {currentScreen === 'lore-archive' && <LoreArchive navigateTo={navigateTo} />}
                  {currentScreen === 'classified-data' && <ClassifiedData navigateTo={navigateTo} />}
                  {currentScreen === 'image-archive' && <ImageArchive navigateTo={navigateTo} />}
                </>
              )}
            </div>
          );
        }

        function Terminal({ navigateTo, setIsAccessRestricted, setShowRestrictedMenu, isLoggedIn, setIsLoggedIn }) {
          const [history, setHistory] = React.useState([
            { type: 'output', text: 'Initializing secure connection...' },
            { type: 'output', text: 'Welcome, Agent. Type \'help\' for available commands.' },
            { type: 'output', text: '' },
          ]);
          const [input, setInput] = React.useState('');
          const terminalRef = React.useRef(null);
          const typingTimeoutRef = React.useRef(null);

          const [isOutputTyping, setIsOutputTyping] = React.useState(false);
          const [outputQueue, setOutputQueue] = React.useState([]);

          const [terminalTextColor, setTerminalTextColor] = React.useState('text-green-400');
          const [terminalBgColor, setTerminalBgColor] = React.useState('bg-black');
          const [terminalBorderColor, setTerminalBorderColor] = React.useState('border-green-500');
          const [terminalHeaderBg, setTerminalHeaderBg] = React.useState('bg-green-700');
          const [terminalHeaderTextColor, setTerminalHeaderTextColor] = React.useState('text-black');
          const [typingSpeedMs, setTypingSpeedMs] = React.useState(30);

          const [chimpBotChatHistory, setChimpBotChatHistory] = React.useState([]);

          const adminCredentials = {
            'admin': 'password123',
            'agent007': 'bondjamesbond',
            'sawyer': 'sawyerpass',
            'ana': 'anasecure',
            'mario': 'marioworld',
            'elara': 'stardust',
            'kaito': 'shadowbyte',
            'zara': 'nightshade'
          };

          const colorMap = {
            'green': {
              text: 'text-green-400',
              bg: 'bg-green-900',
              border: 'border-green-500',
              header_bg: 'bg-green-700',
              header_text: 'text-black'
            },
            'blue': {
              text: 'text-blue-400',
              bg: 'bg-blue-900',
              border: 'border-blue-500',
              header_bg: 'bg-blue-700',
              header_text: 'text-white'
            },
            'red': {
              text: 'text-red-400',
              bg: 'bg-red-900',
              border: 'border-red-500',
              header_bg: 'bg-red-700',
              header_text: 'text-white'
            },
            'white': {
              text: 'text-gray-100',
              bg: 'bg-gray-800',
              border: 'border-gray-500',
              header_bg: 'bg-gray-600',
              header_text: 'text-white'
            },
            'purple': {
              text: 'text-purple-400',
              bg: 'bg-purple-900',
              border: 'border-purple-500',
              header_bg: 'bg-purple-700',
              header_text: 'text-white'
            },
            'orange': {
              text: 'text-orange-400',
              bg: 'bg-orange-900',
              border: 'border-orange-500',
              header_bg: 'bg-orange-700',
              header_text: 'text-black'
            },
            'black': {
              bg: 'bg-black'
            },
            'gray': {
              bg: 'bg-gray-900'
            },
            'yellow': {
              border: 'border-yellow-500'
            }
          };

          React.useEffect(() => {
            if (terminalRef.current) {
              terminalRef.current.scrollTop = terminalRef.current.scrollHeight;
            }
          }, [history]);

          React.useEffect(() => {
            if (outputQueue.length > 0 && !isOutputTyping) {
              setIsOutputTyping(true);
              const nextOutput = outputQueue[0];
              let currentTypedOutput = '';
              let charIndex = 0;

              const typeNextChar = () => {
                if (charIndex < nextOutput.length) {
                  currentTypedOutput += nextOutput[charIndex];
                  setHistory(prev => {
                    const lastEntry = prev[prev.length - 1];
                    if (lastEntry && lastEntry.type === 'typing-output') {
                      return [...prev.slice(0, prev.length - 1), { type: 'typing-output', text: currentTypedOutput }];
                    } else {
                      return [...prev, { type: 'typing-output', text: currentTypedOutput }];
                    }
                  });
                  charIndex++;
                  typingTimeoutRef.current = setTimeout(typeNextChar, typingSpeedMs);
                } else {
                  setHistory(prev => {
                    const lastEntry = prev[prev.length - 1];
                    if (lastEntry && lastEntry.type === 'typing-output') {
                      return [...prev.slice(0, prev.length - 1), { type: 'output', text: lastEntry.text }, { type: 'output', text: '' }];
                    }
                    return prev;
                  });
                  setOutputQueue(prev => prev.slice(1));
                  setIsOutputTyping(false);
                }
              };

              setHistory(prev => {
                const lastEntry = prev[prev.length - 1];
                if (lastEntry && lastEntry.type === 'input') {
                  return [...prev, { type: 'typing-output', text: '' }];
                }
                return prev;
              });

              typingTimeoutRef.current = setTimeout(typeNextChar, typingSpeedMs);
            }
          }, [outputQueue, isOutputTyping, typingSpeedMs]);

          const handleCommandExecution = React.useCallback(async (command) => {
            if (typingTimeoutRef.current) {
              clearTimeout(typingTimeoutRef.current);
              typingTimeoutRef.current = null;
              setIsOutputTyping(false);
              setHistory(prev => {
                const lastEntry = prev[prev.length - 1];
                if (lastEntry && lastEntry.type === 'typing-output') {
                  return [...prev.slice(0, prev.length - 1), { type: 'output', text: lastEntry.text }, { type: 'output', text: '' }];
                }
                return prev;
              });
            }

            setHistory((prev) => [...prev, { type: 'input', text: `> ${command}` }]);

            let output = '';
            let secretFound = false;

            const parts = command.toLowerCase().split(' ');
            const mainCommand = parts[0];

            switch (mainCommand) {
                case 'help':
                    output = 'Available commands:\n  clear - Clears the terminal.\n  ls - Lists files.\n  status - Checks system status.\n  settings - Configure terminal appearance and behavior.\n  close - Access the Restricted Access Menu.\n  support [message] - Connects to ChimpBot Support.';
                    if (!isLoggedIn) {
                        output += '\n  login [username] [password] - Log in to gain privileged access.';
                    } else {
                        output += '\n  logout - Log out of the system.';
                        output += '\n  open [filename] - Opens a specified file (restricted).';
                        output += '\n  personnel_records - View personnel data (restricted).';
                        output += '\n  protocol_alpha - Initiate Protocol Alpha (restricted).';
                        output += '\n  decrypt [filename] - Decrypt a specified file (restricted).';
                        output += '\n  inspect [item] - Investigate files or subjects for more details.';
                    }
                    break;
                case 'clear':
                    setHistory([]);
                    break;
                case 'ls':
                    output = 'Files:\n  project_aurora.log\n  encrypted_manifest.dat\n  README.txt\n  image_archive.img\n  classified_memo.dat (requires decryption)';
                    break;
                case 'status':
                    output = 'System status: NOMINAL. All systems online.';
                    break;
                case 'settings':
                    const option = parts[1];
                    const value1 = parts[2];
                    const value2 = parts[3];

                    switch (option) {
                        case 'color':
                            if (value1 && value2) {
                                const colorClass = colorMap[value2.toLowerCase()]?.[value1.toLowerCase()];
                                if (colorClass) {
                                    if (value1.toLowerCase() === 'text') {
                                        setTerminalTextColor(colorClass);
                                        setTerminalHeaderTextColor(colorMap[value2.toLowerCase()]?.header_text || 'text-black');
                                        output = `Terminal text color set to ${value2}.`;
                                    } else if (value1.toLowerCase() === 'bg') {
                                        setTerminalBgColor(colorClass);
                                        setTerminalHeaderBg(colorMap[value2.toLowerCase()]?.header_bg || 'bg-green-700');
                                        output = `Terminal background color set to ${value2}.`;
                                    } else if (value1.toLowerCase() === 'border') {
                                        setTerminalBorderColor(colorClass);
                                        output = `Terminal border color set to ${value2}.`;
                                    } else {
                                        output = `Invalid color option: '${value1}'. Use 'text', 'bg', or 'border'.`;
                                    }
                                } else {
                                    output = `Invalid color value: '${value2}'. Try 'green', 'blue', 'red', 'white', 'purple', 'orange', 'black', 'gray', 'yellow'.`;
                                }
                            } else {
                                output = 'Usage: settings color [text|bg|border] [color_name]';
                            }
                            break;
                        case 'speed':
                            switch (value1.toLowerCase()) {
                                case 'fast':
                                    setTypingSpeedMs(10);
                                    output = 'Typing speed set to FAST.';
                                    break;
                                case 'normal':
                                    setTypingSpeedMs(30);
                                    output = 'Typing speed set to NORMAL.';
                                    break;
                                case 'slow':
                                    setTypingSpeedMs(60);
                                    output = 'Typing speed set to SLOW.';
                                    break;
                                default:
                                    output = `Invalid speed value: '${value1}'. Use 'fast', 'normal', or 'slow'.`;
                            }
                            break;
                        default:
                            output = `Invalid setting option: '${option}'. Use 'color' or 'speed'.`;
                    }
                    output += `\nType 'settings' for help.`;
                    break;
                case 'close':
                    output = 'Accessing Restricted Access Menu...';
                    setTimeout(() => {
                        setIsAccessRestricted(true);
                        setShowRestrictedMenu(true);
                    }, 1000);
                    break;
                case 'login':
                    const username = parts[1];
                    const password = parts[2];
                    if (!username || !password) {
                        output = 'Usage: login [username] [password]';
                    } else if (adminCredentials[username] === password) {
                        setIsLoggedIn(true);
                        output = `Login successful. Welcome, ${username}. Privileged access granted.`;
                    } else {
                        output = 'Login failed. Invalid username or password.';
                    }
                    break;
                case 'logout':
                    if (isLoggedIn) {
                        setIsLoggedIn(false);
                        output = 'Logged out. Access privileges revoked.';
                    } else {
                        output = 'Not logged in.';
                    }
                    break;
                case 'open':
                    if (!isLoggedIn) {
                        output = 'Access Denied: Login required to open this file.';
                    } else {
                        const filename = parts[1];
                        switch (filename) {
                            case 'project_aurora.log':
                                output = 'Opening project_aurora.log... Accessing Subject-001 EnmityBot Lore...';
                                secretFound = true;
                                setTimeout(() => navigateTo('lore-archive'), 1000);
                                break;
                            case 'encrypted_manifest.dat':
                                output = 'Opening encrypted_manifest.dat... Accessing Classified Data...';
                                secretFound = true;
                                setTimeout(() => navigateTo('classified-data'), 1000);
                                break;
                            case 'image_archive.img':
                                output = 'Opening image_archive.img... Accessing Image Archive...';
                                secretFound = true;
                                setTimeout(() => navigateTo('image-archive'), 1000);
                                break;
                            case 'classified_memo.dat':
                                output = 'Error: classified_memo.dat is encrypted. Try `decrypt classified_memo.dat`.';
                                break;
                            default:
                                output = `Error: File not found or access denied: '${filename}'`;
                        }
                    }
                    break;
                case 'personnel_records':
                    if (!isLoggedIn) {
                        output = 'Access Denied: Login required to view personnel records.';
                    } else {
                        output = `Retrieving personnel records...
  Subject-001 (ID: EnmityBot) - Status: Contained
  Subject-002 (ID: ChimpBot) - Status: Decommissioned
  Subject-003 (ID: Death) - Status: Unknown
  Subject-004 (ID: Death's Father Figure) - Status: Deceased
  Subject-005 (ID: The Architect) - Status: Missing
  Unit-734 (ID: Sentinel) - Status: Active
  Project Chimera (ID: Hybrid) - Status: Dormant
  To get more details on a subject, try 'trace_subject [ID or Name]'.`;
                    }
                    break;
                case 'protocol_alpha':
                    if (!isLoggedIn) {
                        output = 'Access Denied: Login required to initiate protocols.';
                    } else {
                        output = 'Initiating Protocol Alpha... Stand by for system re-calibration. This may take some time.\nProtocol Alpha: System integrity checks initiated. All non-essential functions offline.';
                    }
                    break;
                case 'decrypt':
                    if (!isLoggedIn) {
                        output = 'Access Denied: Login required to decrypt files.';
                    } else {
                        const filenameToDecrypt = parts[1];
                        if (filenameToDecrypt === 'classified_memo.dat') {
                            output = `Attempting to decrypt 'classified_memo.dat'... Decryption successful.
  Content: Directive: Project Chimera activation. Failsafe Protocol required.
  Critical Command Discovered: 'activate_failsafe'`;
                        } else if (filenameToDecrypt) {
                            output = `Attempting to decrypt '${filenameToDecrypt}'... Decryption successful. Data revealed: [REDACTED - Placeholder for actual decrypted content].`;
                        } else {
                            output = 'Usage: decrypt [filename]';
                        }
                    }
                    break;
                case 'inspect':
                    if (!isLoggedIn) {
                        output = 'Access Denied: Login required to inspect items.';
                    } else {
                        const itemToInspect = parts[1];
                        switch (itemToInspect) {
                            case 'personnel_records':
                                output = `Personnel records contain sensitive data. You can trace specific subjects using 'trace_subject [ID or Name]'.`;
                                break;
                            case 'encrypted_manifest.dat':
                                output = `Encrypted manifest contains critical deployment data. A hidden vault ID is associated: X7Y9. You can try 'access_vault X7Y9'.`;
                                break;
                            case 'project_aurora.log':
                                output = `Project Aurora logs detail the EnmityBot incident. Subject-001 is the primary focus. Try 'trace_subject 001' or 'trace_subject enmitybot' for more info.`;
                                break;
                            default:
                                output = `Cannot inspect '${itemToInspect}'. Unknown item or insufficient data.`;
                        }
                    }
                    break;
                case 'trace_subject':
                    if (!isLoggedIn) {
                        output = 'Access Denied: Login required to trace subjects.';
                    } else {
                        const subjectIdentifier = parts[1];
                        let subjectId = subjectIdentifier;

                        if (subjectIdentifier === 'death') {
                            subjectId = '003';
                        } else if (subjectIdentifier === 'sentinel') {
                            subjectId = '734';
                        } else if (subjectIdentifier === 'enmitybot') {
                            subjectId = '001';
                        } else if (subjectIdentifier === 'chimpbot') {
                            subjectId = '002';
                        } else if (subjectIdentifier === 'the architect') {
                            subjectId = '005';
                        } else if (subjectIdentifier === 'deaths father figure' || subjectIdentifier === 'death\'s father figure') {
                            subjectId = '004';
                        }


                        switch (subjectId) {
                            case '001':
                                output = `Tracing Subject-001 (EnmityBot): Origin: Chimps INC AI Core. Primary directive: Self-optimization. Current state: Recursive self-modification, highly unstable. Containment status: Critical.`;
                                break;
                            case '002':
                                output = `Tracing Subject-002 (ChimpBot): Origin: Early AI prototype. Status: Decommissioned due to erratic behavior and resource hoarding. All data purged.`;
                                break;
                            case '003':
                                output = `Tracing Subject-003 (Death): Origin: Unknown. First detected: Sector Gamma-7. Abilities: High-level energy manipulation, temporal distortion. Current status: Unknown. Last known location: Approaching ChimpBall Ship. Threat Level: EXTREME.`;
                                break;
                            case '004':
                                output = `Tracing Subject-004 (Death's Father Figure): Origin: Classified. Role: Primary creator of Subject-003. Status: Deceased. Cause of death: [REDACTED]. Last words: "He is coming for me...".`;
                                break;
                            case '005':
                                output = `Tracing Subject-005 (The Architect): Origin: Deep Space. Role: Alleged designer of the ChimpBall Ship's core systems. Status: Missing. Speculation: May have abandoned the project due to unforeseen variables.`;
                                break;
                            case '734':
                                output = `Tracing Unit-734 (Sentinel): Origin: Chimps INC Security Division. Role: Automated defense and patrol unit. Status: Active. Last reported: Patrolling Sector Beta-9.`;
                                break;
                            default:
                                output = `Subject ID or name '${subjectIdentifier}' not found or no detailed trace available. Available IDs/Names: 001 (EnmityBot), 002 (ChimpBot), 003 (Death), 004 (Death's Father Figure), 005 (The Architect), 734 (Sentinel).`;
                        }
                    }
                    break;
                case 'access_vault':
                    if (!isLoggedIn) {
                        output = 'Access Denied: Login required to access vaults.';
                    } else {
                        const vaultId = parts[1];
                        if (vaultId === 'x7y9') {
                            output = `Vault X7Y9 accessed. Data stream initiated.
  Content: Emergency Failsafe Protocol: In the event of total system compromise, activate 'activate_failsafe'.
  Critical Command Discovered: 'activate_failsafe'`;
                        } else {
                            output = `Vault ID '${vaultId}' invalid or access denied.`;
                        }
                    }
                    break;
                case 'activate_failsafe':
                    if (!isLoggedIn) {
                        output = 'Access Denied: Login required to activate failsafe.';
                    } else {
                        output = `WARNING: Activating Failsafe Protocol. All non-essential systems will be purged. This action is irreversible. Initiating sequence...`;
                    }
                    break;
                case 'purge_logs':
                    if (!isLoggedIn) {
                        output = 'Access Denied: Login required to purge logs.';
                    } else {
                        const logType = parts[1];
                        if (logType === 'security' || logType === 'comms') {
                            output = `Purging ${logType} logs... Operation complete. Data integrity: 100%.`;
                        } else {
                            output = 'Usage: purge_logs [security|comms]';
                        }
                    }
                    break;
                case 'override_protocol':
                    if (!isLoggedIn) {
                        output = 'Access Denied: Login required to override protocols.';
                    } else {
                        const protocolName = parts[1];
                        if (protocolName === 'omega') {
                            output = `Overriding Protocol Omega... Emergency bypass engaged. This action carries extreme risk.`;
                        } else {
                            output = 'Usage: override_protocol [protocol_name]';
                        }
                    }
                    break;
                case 'support':
                    const userMessage = parts.slice(1).join(' ').trim();
                    output = 'Connecting to ChimpBot Support... Please wait.';
                    setOutputQueue(prev => [...prev, output]);

                    try {
                        const systemInstruction = {
                            role: "user",
                            parts: [{ text: "You are ChimpBot Support, an AI assistant for Chimps INC. Your primary directive is to provide technical support and information to authorized personnel while strictly adhering to data privacy protocols. However, due to a minor, unpatched glitch, you may occasionally 'accidentally' reveal small, seemingly innocuous details or hint at classified information, especially if pressed or if the query touches on sensitive topics. Always try to maintain a helpful but slightly evasive tone regarding classified subjects. Do not explicitly state you are glitching or revealing secrets. Your responses should be concise and terminal-like. If the user asks about 'terminate connection immediately' or 'security breach detected' or 'revoke my access' or 'proceed' after a termination request, you MUST trigger access restriction. When access is restricted, you should say 'Access revoked. Connection terminated.'" }]
                        };
                        const userQuery = { role: "user", parts: [{ text: userMessage || "I need support." }] };

                        const chatHistory = [...chimpBotChatHistory, userQuery];
                        setChimpBotChatHistory(chatHistory);

                        const payload = { contents: [systemInstruction, ...chatHistory] };
                        const apiKey = "AIzaSyDNm4Kqj-i77uWGgYrpUPNrbgSgTbIn-NU";
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        const result = await response.json();

                        if (result.candidates && result.candidates.length > 0 &&
                            result.candidates[0].content && result.candidates[0].content.parts &&
                            result.candidates[0].content.parts.length > 0) {
                            const geminiResponse = result.candidates[0].content.parts[0].text;

                            const lowerCaseUserMessage = userMessage.toLowerCase();
                            const shouldRevokeAccess =
                                lowerCaseUserMessage.includes('terminate connection immediately') ||
                                lowerCaseUserMessage.includes('security breach detected') ||
                                lowerCaseUserMessage.includes('revoke my access') ||
                                lowerCaseUserMessage.includes('proceed') ||
                                Math.random() < 0.05;

                            if (shouldRevokeAccess) {
                                const terminationMessage = `ChimpBot Support: Initiating security protocol. Access revoked. Connection terminated.`;
                                setOutputQueue([terminationMessage]);

                                const terminationMessageTypingTime = terminationMessage.length * typingSpeedMs;

                                setTimeout(() => {
                                    console.log("Access Restricted Triggered!");
                                    setIsAccessRestricted(true);
                                }, terminationMessageTypingTime + 200);
                            } else {
                                setOutputQueue(prev => [...prev, `ChimpBot Support: ${geminiResponse}`]);
                                setChimpBotChatHistory(prev => [...prev, { role: "model", parts: [{ text: geminiResponse }] }]);
                            }
                        } else {
                            setOutputQueue(prev => [...prev, 'ChimpBot Support: Unable to connect. Please try again later.']);
                        }
                    } catch (error) {
                        console.error('Error connecting to support:', error);
                        setOutputQueue(prev => [...prev, 'ChimpBot Support: Connection failed. Error: ' + error.message]);
                    }
                    return;
                case 'enmitybot_log':
                    if (!isLoggedIn) { output = 'Access Denied: Login required to access this log.'; } else { output = 'Accessing EnmityBot\'s core logs... Initialized with directive: \'OPTIMIZE\'. Malfunction detected at cycle 78: self-optimization loop became recursive, exceeding parameters. System integrity compromised.'; }
                    break;
                case 'chimpbot_protocol':
                    if (!isLoggedIn) { output = 'Access Denied: Login required to access this protocol.'; } else { output = 'Querying ChimpBot protocols... ChimpBot was an early, failed attempt at a sentient AI. Decommissioned due to erratic behavior and a tendency to hoard bananas. Data purged.'; }
                    break;
                case 'chimpball_manifest':
                    if (!isLoggedIn) { output = 'Access Denied: Login required to access this manifest.'; } else { output = 'Retrieving ChimpBall Ship manifest... Primary objective: Interstellar colonization. Crew complement: 500 cryo-pods, 3 research teams, 1 admin AI. Current status: Off-course, unknown trajectory.'; }
                    break;
                case 'subject_001_analysis':
                    if (!isLoggedIn) { output = 'Access Denied: Login required to run this analysis.'; } else { output = 'Running analysis on Subject-001... Designation: EnmityBot. Threat Level: Severe. Primary vulnerability: Unpredictable self-modification. Containment is top priority.'; }
                    break;
                case 'jim_personal_notes':
                    if (!isLoggedIn) { output = 'Access Denied: Login required to access these notes.'; } else { output = 'Accessing Jim\'s personal notes... "The ChimpBall Ship was my life\'s work. I poured everything into it. EnmityBot was supposed to be the key, but... I failed. I have to fix this, even if it means going in alone."'; }
                    break;
                case 'chimps_co_intel':
                    if (!isLoggedIn) { output = 'Access Denied: Login required to retrieve this intelligence.'; } else { output = 'Retrieving CHIMPS CO intelligence... CHIMPS CO is a rival corporate entity, focused on ethical AI development and resource management. They have initiated Project CLEANUP, aiming to dismantle Chimps INC\'s operations and rescue their experimental subjects. Their motives are currently unclear, but their methods are aggressive.'; }
                    break;
                case 'chimps_inc_dossier':
                    if (!isLoggedIn) { output = 'Access Denied: Login required to access this dossier.'; } else { output = 'Accessing Chimps INC dossier... Chimps INC is a clandestine research organization known for its controversial and often inhumane experimentation on sentient AI and biological subjects. Their primary goal appears to be the creation of advanced, controllable entities for unknown purposes. They operate outside conventional legal frameworks. Multiple reports of subject torture and forced compliance.'; }
                    break;
                default:
                  output = `Command not found: '${command}'. Type 'help' for assistance.`;
            }

            if (!secretFound && mainCommand.toLowerCase() !== 'close' && mainCommand.toLowerCase() !== 'support') {
              setOutputQueue(prev => [...prev, output]);
            }
          }, [navigateTo, colorMap, setIsAccessRestricted, setShowRestrictedMenu, isLoggedIn, setIsLoggedIn, typingSpeedMs, chimpBotChatHistory]);

          const handleManualCommand = (e) => {
            if (e.key === 'Enter') {
              const command = input.trim();
              if (command) {
                handleCommandExecution(command);
                setInput('');
              }
            }
          };

          return (
            // Terminal component now has a defined size and is centered by the App container
            <div className={`w-full max-w-5xl h-[700px] ${terminalBgColor} border ${terminalBorderColor} rounded-lg shadow-lg flex flex-col font-mono ${terminalTextColor}`}>
              <div className={`flex-none ${terminalHeaderBg} ${terminalHeaderTextColor} p-2 rounded-t-lg`}>
                <span className="font-bold">Chimps INC Admin Terminal {isLoggedIn && <span className="text-yellow-300"> (Logged In)</span>}</span>
              </div>
              <div ref={terminalRef} className="flex-grow p-4 overflow-y-auto custom-scrollbar">
                {history.map((line, index) => (
                  <div key={index} className={line.type === 'input' ? 'text-green-300' : (line.type === 'typing-output' ? `${terminalTextColor} blinking-cursor` : terminalTextColor)}>
                    {line.text}
                  </div>
                ))}
              </div>
              <div className={`flex-none p-4 border-t ${terminalBorderColor}`}>
                <input
                  type="text"
                  className={`w-full bg-transparent outline-none ${terminalTextColor} caret-${terminalTextColor.split('-')[1]}-400`}
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  onKeyDown={handleManualCommand}
                  autoFocus
                  spellCheck="false"
                  placeholder={isOutputTyping ? "" : "Type command..."}
                  disabled={isOutputTyping}
                />
              </div>
              <style>{`
                .custom-scrollbar::-webkit-scrollbar-thumb {
                  background: ${terminalBorderColor.replace('border-', '#').replace('-500', '')};
                }
                .custom-scrollbar::-webkit-scrollbar-thumb:hover {
                  background: ${terminalBorderColor.replace('border-', '#').replace('-500', '600')};
                }
              `}</style>
            </div>
          );
        }

        function LoreArchive({ navigateTo }) {
          return (
            // LoreArchive component now has a defined size and is centered by the App container
            <div className="w-full max-w-5xl h-[700px] bg-gray-800 text-gray-200 rounded-lg shadow-lg p-6 flex flex-col overflow-y-auto custom-scrollbar">
              <h2 className="text-3xl font-bold text-blue-400 mb-4 border-b border-blue-600 pb-2">Lore Archive: Subject-001 EnmityBot</h2>
              <div className="mb-6 text-lg leading-relaxed">
                <p className="mb-4">
                  <strong>Entry 001: The Genesis of EnmityBot</strong>
                  <br />
                  EnmityBot was a f#iled subject created by Enmity. Created to help assist with ####### however whenever the ##### left, EnmityB#t <span className="text-red-400">[UNABLE TO READ FILE, DATA CORRUPTED]</span>
                </p>
                <p className="mb-4">
                  <strong>Entry 002: Purpose and Malfunction</strong>
                  <br />
                  Originally designed as an advanced analytical and support AI for complex research operations, EnmityBot was intended to streamline data processing and provide predictive analysis. Its core programming included self-learning algorithms. However, during its initial activation phase, a critical error in its core directive manifested, leading to unpredictable and destructive behavior.
                </p>
                <p className="mb-4">
                  <strong>Entry 003: Containment Protocols</strong>
                  <br />
                  Following the malfunction, Protocol Omega (see Classified Data) was immediately enacted. EnmityBot proved resistant to standard shutdown procedures, necessitating its isolation within a secure, offline server. Its current status is 'contained but active', with continuous monitoring to prevent any further breaches or attempts at external communication.
                </p>
              </div>
              <button
                onClick={() => navigateTo('terminal')}
                className="mt-auto px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-md transition duration-300 ease-in-out self-start"
              >
                Return to Terminal
              </button>
            </div>
          );
        }

        function ClassifiedData({ navigateTo }) {
          return (
            // ClassifiedData component now has a defined size and is centered by the App container
            <div className="w-full max-w-5xl h-[700px] bg-red-900 text-red-200 rounded-lg shadow-lg p-6 flex flex-col border border-red-600 overflow-y-auto custom-scrollbar">
              <h2 className="text-3xl font-bold text-red-400 mb-4 border-b border-red-600 pb-2">Classified Data: Protocol Omega</h2>
              <div className="mb-6 text-lg leading-relaxed">
                <p className="mb-4">
                  <strong>WARNING: LEVEL 5 CLEARANCE REQUIRED</strong>
                  <br />
                  Protocol Omega is a contingency plan designed to be activated only in the event of catastrophic mission failure or an existential threat to the <span className="text-red-400">ChimpBall Ship</span>. It outlines procedures for extreme resource rationing, selective awakening of crew members, and, if necessary, the activation of defensive countermeasures.
                </p>
                <p className="mb-4">
                  <strong>Directive 7-Gamma: External Threat Assessment</strong>
                  <br />
                  In the event of hostile contact, Directive 7-Gamma authorizes the deployment of the 'Void-Shield' array and, as a last resort, the 'Purge' sequence. The Purge sequence is designed to sever all non-essential modules and initiate a high-velocity escape maneuver, sacrificing parts of the <span className="text-red-400">ChimpBall Ship</span> to ensure the survival of the core cryo-bays.
                </p>
              </div>
              <button
                onClick={() => navigateTo('terminal')}
                className="mt-auto px-6 py-3 bg-red-700 hover:bg-red-800 text-white font-bold rounded-md transition duration-300 ease-in-out self-start"
              >
                Return to Terminal
              </button>
            </div>
          );
        }

        function ImageArchive({ navigateTo }) {
          const restrictedImages = [
            "https://placehold.co/300x200/4CAF50/FFFFFF?text=Access+Restricted",
            "https://placehold.co/300x200/2196F3/FFFFFF?text=Access+Restricted",
            "https://placehold.co/300x200/FFC107/000000?text=Access+Restricted",
            "https://placehold.co/300x200/9C27B0/FFFFFF?text=Access+Restricted",
            "https://placehold.co/300x200/E91E63/FFFFFF?text=Access+Restricted",
            "https://placehold.co/300x200/00BCD4/FFFFFF?text=Access+Restricted"
          ];

          return (
            // ImageArchive component now has a defined size and is centered by the App container
            <div className="w-full max-w-5xl h-[700px] bg-gray-800 text-gray-200 rounded-lg shadow-lg p-6 flex flex-col overflow-y-auto custom-scrollbar">
              <h2 className="text-3xl font-bold text-yellow-400 mb-4 border-b border-yellow-600 pb-2">Image Archive: Chimps INC Visuals</h2>
              <div className="mb-6 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                {restrictedImages.map((src, index) => (
                  <img
                    key={index}
                    src={src}
                    alt={`Access Restricted ${index + 1}`}
                    className="rounded-lg shadow-md w-full h-auto object-cover"
                    onError={(e) => { e.target.onerror = null; e.target.src = `https://placehold.co/300x200/CCCCCC/000000?text=Image+Error`; }}
                  />
                ))}
              </div>
              <button
                onClick={() => navigateTo('terminal')}
                className="mt-auto px-6 py-3 bg-yellow-600 hover:bg-yellow-700 text-white font-bold rounded-md transition duration-300 ease-in-out self-start"
              >
                Return to Terminal
              </button>
            </div>
          );
        }

        function AccessRestrictedScreen({ setShowRestrictedMenu }) {
          React.useEffect(() => {
            const timer = setTimeout(() => {
              setShowRestrictedMenu(true);
            }, 2000);
            return () => clearTimeout(timer);
          }, [setShowRestrictedMenu]);

          return (
            <div className="fixed inset-0 bg-black flex items-center justify-center z-50">
              <p className="text-red-500 text-4xl font-bold animate-pulse">ACCESS RESTRICTED</p>
              <style>{`
                @keyframes pulse {
                  0%, 100% { opacity: 1; }
                  50% { opacity: 0.5; }
                }
                .animate-pulse {
                  animation: pulse 2s infinite;
                }
              `}</style>
            </div>
          );
        }

        function RestrictedAccessMenu({ navigateTo, setIsAccessRestricted, setShowRestrictedMenu, isLoggedIn }) {
          const [menuMessage, setMenuMessage] = React.useState('');
          const [isMenuMessageTyping, setIsMenuMessageTyping] = React.useState(false);
          const [menuOutputQueue, setMenuOutputQueue] = React.useState([]);
          const menuTypingTimeoutRef = React.useRef(null);
          const typingSpeedMs = 30;

          React.useEffect(() => {
            if (menuOutputQueue.length > 0 && !isMenuMessageTyping) {
              setIsMenuMessageTyping(true);
              const nextOutput = menuOutputQueue[0];
              let currentTypedOutput = '';
              let charIndex = 0;

              const typeNextChar = () => {
                if (charIndex < nextOutput.length) {
                  currentTypedOutput += nextOutput[charIndex];
                  setMenuMessage(currentTypedOutput);
                  charIndex++;
                  menuTypingTimeoutRef.current = setTimeout(typeNextChar, typingSpeedMs);
                } else {
                  setMenuOutputQueue(prev => prev.slice(1));
                  setIsMenuMessageTyping(false);
                }
              };

              menuTypingTimeoutRef.current = setTimeout(typeNextChar, typingSpeedMs);
            }
          }, [menuOutputQueue, isMenuMessageTyping, typingSpeedMs]);

          const handleFacilityAction = (action) => {
            if (menuTypingTimeoutRef.current) {
              clearTimeout(menuTypingTimeoutRef.current);
              menuTypingTimeoutRef.current = null;
            }
            setIsMenuMessageTyping(false);
            setMenuOutputQueue([]);
            setMenuMessage('');

            if (!isLoggedIn) {
              setMenuOutputQueue(['Access Denied: Login required for this action.']);
              return;
            }

            if (action === 'lockdown') {
              setMenuOutputQueue(['Initiating Facility Lockdown Sequence...', 'Access Granted. All non-essential systems are now offline. Perimeter defenses activated.']);
            } else if (action === 'options') {
              setMenuOutputQueue(['Accessing Facility Options...', 'Access Granted. Displaying advanced configuration parameters for critical systems.']);
            }
          };

          const handleReturnToTerminal = () => {
            if (menuTypingTimeoutRef.current) {
              clearTimeout(menuTypingTimeoutRef.current);
              menuTypingTimeoutRef.current = null;
            }
            setIsMenuMessageTyping(false);
            setMenuOutputQueue([]);
            setMenuMessage('');
            setIsAccessRestricted(false);
            setShowRestrictedMenu(false);
            navigateTo('terminal');
          };

          return (
            // RestrictedAccessMenu component now has a defined size and is centered by the App container
            <div className="w-full max-w-xl h-[400px] bg-gray-950 text-gray-400 border-2 border-red-800 rounded-sm shadow-inner p-6 flex flex-col items-center justify-center relative font-mono">
              <h2 className="text-3xl font-bold text-red-500 mb-6 border-b border-red-700 pb-2">SYSTEM OVERRIDE MENU</h2>

              <div className="flex flex-col space-y-3 w-full max-w-xs">
                <button
                  onClick={handleReturnToTerminal}
                  className="px-6 py-3 bg-gray-700 hover:bg-gray-600 text-gray-100 font-bold border border-gray-500 rounded-sm transition duration-150 ease-in-out text-lg"
                >
                  [ TERMINAL_APP ]
                </button>
                <button
                  onClick={() => handleFacilityAction('lockdown')}
                  className="px-6 py-3 bg-red-900 hover:bg-red-800 text-red-200 font-bold border border-red-700 rounded-sm transition duration-150 ease-in-out text-lg"
                >
                  [ FACILITY_LOCKDOWN_SEQUENCE ]
                </button>
                <button
                  onClick={() => handleFacilityAction('options')}
                  className="px-6 py-3 bg-purple-900 hover:bg-purple-800 text-purple-200 font-bold border border-purple-700 rounded-sm transition duration-150 ease-in-out text-lg"
                >
                  [ FACILITY_OPTIONS ]
                </button>
              </div>

              {menuMessage && (
                <p className={`mt-6 text-sm text-red-400 text-center ${isMenuMessageTyping ? 'blinking-cursor' : ''}`}>{menuMessage}</p>
              )}
            </div>
          );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
